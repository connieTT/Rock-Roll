# Author: Tongtong Zhao && Saozhong Han
import numpy as np
import math
import cv2
import itertools

def detectBlobs(im):
    """ Takes and image and locates the potential location(s) of the red marker
        on top of the robot

    Hint: bgr is the standard color space for images in OpenCV, but other color
          spaces may yield better results

    Note: you are allowed to use OpenCV function calls here

    Returns:
      keypoints: the keypoints returned by the SimpleBlobDetector, each of these
                 keypoints has pt and size values that should be used as
                 measurements for the particle filter
    """
    im = im[:,:,1]
    _,im = cv2.threshold(im, 140, 170, cv2.THRESH_BINARY)
    params = cv2.SimpleBlobDetector_Params()
    params.minThreshold = 0;
    params.maxThreshold = 255;
    params.thresholdStep = 10;

    params.filterByColor = False

    params.filterByArea = True
    params.minArea = 100
    params.maxArea = 100000000000

    params.filterByCircularity = False
    params.minCircularity = 0
    params.maxCircularity = 1

    params.filterByConvexity = False
    params.minConvexity = 0
    params.maxConvexity = 1

    params.filterByInertia = False
    params.minInertiaRatio = 0
    params.maxInertiaRatio = 1

    detector = cv2.SimpleBlobDetector(params)
    keypoints = detector.detect(im)
    return keypoints

def predict(particles, predictSigma):
    """ Predict particles one step forward. The motion model should be additive
        Gaussian noise with sigma predictSigma

    Returns:
      particles: list of predicted particles (same size as input particles)
    """
    for i in range(len(particles)):
        particles[i] = (np.random.normal(particles[i][0],predictSigma),np.random.normal(particles[i][1],predictSigma))
    return particles

def update(particles, weights, keypoints):
    """ Resample particles and update weights accordingly after particle filter
        update

    Returns:
      newParticles: list of resampled partcles of type np.array
      weights: weights updated after sampling
    """
    clusters = {tuple(p): [k.pt for k in keypoints] for p in particles}
    delta = {tuple(p): [(x-p[0],y-p[1]) for x,y in clusters[tuple(p)]] for p in particles}
    dist = {tuple(p): [math.hypot(dx,dy) for dx,dy in delta[tuple(p)]] for p in particles}
    for i,p in enumerate(particles):
        d = np.min(dist[tuple(p)])
        weights[i] = 1 / (d**2)
    weights = weights / np.sum(weights)

    return particles, weights

def resample(particles, weights):
    """ Resample particles and update weights accordingly after particle filter
        update

    Returns:
      newParticles: list of resampled partcles of type np.array
      wegiths: weights updated after sampling
    """
    percent = 0.1
    best = particles[np.argsort(weights)][len(particles)*(1-percent):]
    prob = weights[np.argsort(weights)][len(particles)*(1-percent):]
    sample = np.random.choice(np.arange(len(best)), size = (len(particles) - len(best)), p = (prob/np.sum(prob)))
    resample = best[sample]

    newParticles = np.concatenate((np.asarray(best), np.asarray(resample)))
    weights = np.concatenate((prob, np.ones(len(resample)))) 
    weights = weights / np.sum(weights)

    return newParticles, weights 

def visualizeParticles(im, particles, weights, color=(0,0,255)):
    """ Plot particles as circles with radius proportional to weight, which
        should be [0-1], (default color is red). Also plots weighted average
        of particles as blue circle. Particles should be a numpy.ndarray of
        [x, y] particle locations.

    Returns:
      im: image with particles overlaid as red circles
    """
    im_with_particles = im.copy()
    s = (0, 0)
    for i in range(0, len(particles)):
      s += particles[i]*weights[i]
      cv2.circle(im_with_particles, tuple(particles[i].astype(int)), radius=int(weights[i]*250), color=(0,0,255), thickness=3)
    cv2.circle(im_with_particles, tuple(s.astype(int)), radius=3, color=(255,0,0), thickness=6)
    return im_with_particles

def visualizeKeypoints(im, keypoints, color=(0,255,0)):
    """ Draw keypoints generated by blob detector on image in color specified
        (default is green)

    Returns:
      im_with_keypoints: the image with keypoints overlaid
    """
    # cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS ensures the size of the circle corresponds to the size of blob
    im_with_keypoints = cv2.drawKeypoints(im, keypoints, np.array([]), color, cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)
    return im_with_keypoints

if __name__ == "__main__":
  """ Iterate through a dataset of sequential images and use a blob detector and
      particle filter to track the robot(s) visible in the images. A couple
      helper functions were included to visualize blob keypoints and particles.

  """

  #some initial variables you can use
  imageSet='ImageSet2'
  imageWidth = 1280
  imageHeight = 800
  numParticles = 1000
  initialScale = 50
  predictionSigma = 150
  x0 = np.array([600, 300])  #seed location for particles
  # initialize uniform distribution with all weights = 1 / N
  particles = np.asarray([(x,y) for x,y in
          zip(np.random.randint(0,imageWidth,size=numParticles),
              np.random.randint(0,imageHeight,size=numParticles))])
  weights = np.ones((numParticles,)) / numParticles

  for i in range(0, 19):
    #read in next image
    im = cv2.imread(imageSet+'/'+imageSet+'_' + '%02d.jpg'%i)
    yuv = cv2.cvtColor(im, cv2.COLOR_BGR2YUV)

    #visualize particles
    im_to_show = visualizeParticles(im, particles, weights)
    cv2.imshow("Current Particles", im_to_show)
    cv2.imwrite('processed/'+imageSet+'_' + '%02d_'%i+'1_Current.jpg', im_to_show)

    #predict forward
    particles = predict(particles, predictionSigma)
    im_to_show = visualizeParticles(im, particles, weights)
    cv2.imshow("Prediction", im_to_show)
    cv2.imwrite('processed/'+imageSet+'_' + '%02d_'%i+'2_Predicted.jpg', im_to_show)

    #detected keypoint in measurement
    keypoints = detectBlobs(yuv)

    #update paticleFilter using measurement if there was one
    if keypoints:
      particles, weights = update(particles, weights, keypoints)

    im_to_show = visualizeKeypoints(im, keypoints)
    im_to_show = visualizeParticles(im_to_show, particles, weights)
    cv2.imshow("Reweighted", im_to_show)
    cv2.imwrite('processed/'+imageSet+'_' + '%02d_'%i+'3_Reweighted.jpg', im_to_show)

    #resample particles
    particles, weights = resample(particles, weights)
    im_to_show = visualizeKeypoints(im, keypoints)
    im_to_show = visualizeParticles(im_to_show, particles, weights)
    cv2.imshow("Resampled", im_to_show)
    cv2.imwrite('processed/'+imageSet+'_' + '%02d_'%i+'4_Resampled.jpg', im_to_show)
    cv2.waitKey(0)

